/**
 * The variable player contains:
 * -> 1 if you are the MASTER, who created the room
 * -> 2 if you are the SLAVE, who is connected to the master
 */
var player;

var lastPeerId = null;
var peer = null; // The own peer object
var conn = null; // The connection, event-listener variable
var masterNickname;
var slaveNickname;
var round = 0;

// The tic tac toe grid, initially empty (all cells are setted to 0)
var grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

// The boolean isMyTurn variable indicates whether is the turn of this player
var isMyTurn = false;


/**
 * Change from a page to another
 * These pages are called "slide" and they are some div which
 * are setted to visible or invisible through a CSS class
 */
function toSlide(id) {
    document.querySelectorAll("div.slide").forEach(function(e) {
        e.classList.add("hidden");
        e.classList.remove("visible");
        e.querySelectorAll("*").forEach(function(e2) {
            e2.tabIndex = "-1";
        })
    })

    let d = document.getElementById(id);
    d.classList.add("visible");
    d.classList.remove("hidden");
    d.querySelectorAll("*").forEach(function(e2) {
        e2.tabIndex = "";
    })
}

var buttonNewGame = document.getElementById("btnNewGame");
var buttonExistingGame = document.getElementById("btnExistGame");

buttonNewGame.addEventListener('click', function action() {
    toSlide("newGamePage");
    player = 1;
})

buttonExistingGame.addEventListener('click', function action() {
    toSlide("existingGamePage");
    player = 2;
})

//MASTER SIDE
var createGame = document.getElementById("createGame");
createGame.addEventListener('click', function openConnection(){
    var divMasterStatus = document.getElementById("masterStatus");
    masterNickname = document.getElementById("masterNickname").value;

    /**
     * Managing the MASTER connection.
     */
    function initializeMaster() {

        /**
         * Create own peer object with connection to shared PeerJS server
         * The ID is generated by the generetingId() function
         */
        peer = new Peer(generatingId(), {
            debug: 2
        });

        // Manage the connection opened event
        peer.on('open', function (id) {
            // Workaround for peer.reconnect deleting previous id
            if (peer.id === null) {
                console.log('Received null id from peer open');
                peer.id = lastPeerId;
            } else {
                lastPeerId = peer.id;
            }

            console.log('ID: ' + peer.id);
            divMasterStatus.innerText = "Room id: "+ peer.id + "\n" + "Awaiting connection...";
        });

        // Manage the event generated by the connection of a slave to the master
        peer.on('connection', function (c) {
            // Allow only a single connection
            if (conn && conn.open) {
                c.on('open', function() {
                    c.send("Already connected to another client");
                    setTimeout(function() { c.close(); }, 500);
                });
                return;
            }

            conn = c;
            console.log("Connected to: " + conn.peer);
            divMasterStatus.innerHTML = "Connected";
            ready();
        });

        // Manage the disconnection event
        peer.on('disconnected', function () {
            divMasterStatus.innerHTML = "Connection lost. Please reconnect";
            console.log('Connection lost. Please reconnect');

            // Workaround for peer.reconnect deleting previous id
            peer.id = lastPeerId;
            peer._lastServerId = lastPeerId;
            peer.reconnect();
        });

        // Manage the closed connection event
        peer.on('close', function() {
            conn = null;
            divMasterStatus.innerHTML = "Connection destroyed. Please refresh";
            console.log('Connection destroyed');
        });

        // Manage the errors
        peer.on('error', function (err) {
            console.log(err);
            alert('' + err);
        });
    };

    /**
     * Triggered once a connection has been achieved.
     * Enable the game-start button on MASTER side.
     */
    function ready() {
        var buttonStart = document.createElement('button');
        buttonStart.innerText = "Start";
        buttonStart.addEventListener('click', function startGame(){
            conn.send(masterNickname);
            toSlide("gamePage");
            gameManager();
        })
        var newGamePage = document.getElementById('newGamePage');
        newGamePage.appendChild(buttonStart);

        // Manage che connection closed event
        conn.on('close', function () {
            divMasterStatus.innerHTML = "Connection reset<br>Awaiting connection...";
            conn = null;
        });
    }

    initializeMaster();
})

//SLAVE SIDE
connectGame = document.getElementById("connect");
connectGame.addEventListener('click', function connectClicked() {
    var divSlaveStatus = document.getElementById("slaveStatus");
    slaveNickname = document.getElementById("slaveNickname").value;
    var opponentId = document.getElementById("opponentId").value;

    function initializeSlave() {
        // Create own peer object with connection to shared PeerJS server
        peer = new Peer(generatingId(), {
            debug: 2
        });

        // Manage the connection opened event
        peer.on('open', function (id) {
            // Workaround for peer.reconnect deleting previous id
            if (peer.id === null) {
                console.log('Received null id from peer open');
                peer.id = lastPeerId;
            } else {
                lastPeerId = peer.id;
            }

            console.log('ID: ' + peer.id);
        });

        // Manage the event generated by the connection of another peer by disallowing it
        peer.on('connection', function (c) {
            // Disallow incoming connections
            c.on('open', function() {
                c.send("Sender does not accept incoming connections");
                setTimeout(function() { c.close(); }, 500);
            });
        });

        // Manage the disconnection event
        peer.on('disconnected', function () {
            divSlaveStatus.innerHTML = "Connection lost. Please reconnect";
            console.log('Connection lost. Please reconnect');

            // Workaround for peer.reconnect deleting previous id
            peer.id = lastPeerId;
            peer._lastServerId = lastPeerId;
            peer.reconnect();
        });

        // Manage the closed connection event
        peer.on('close', function() {
            conn = null;
            divSlaveStatus.innerHTML = "Connection destroyed. Please refresh";
            console.log('Connection destroyed');
        });

        // Manage the errors
        peer.on('error', function (err) {
            console.log(err);
            alert('' + err);
        });
    };

    /**
     * This function connect the SLAVE to the MASTER
     * by using the MASTER ID.
     */
    function join() {
        // Close old connection
        if (conn) {
            conn.close();
        }

        // Create connection to destination peer specified in the input field
        conn = peer.connect(opponentId, {
            reliable: true
        });

        // Manage the connection opened event
        conn.on('open', function () {
            divSlaveStatus.innerHTML = "Connected to: " + conn.peer;
            console.log("Connected to: " + conn.peer);
            connectGame.removeEventListener('click', connectClicked);
            conn.send(slaveNickname);
            gameManager();
        });
        
        // Manage the closed connection event
        conn.on('close', function () {
            divSlaveStatus.innerHTML = "Connection closed";
        });

    };

   
    initializeSlave();
    setTimeout(join, 1000); // After the initialization, wait 1s, then join to the master
});    


/**
 * The MASTER and the SLAVE exchange messages using
 * the conn.send() function (contained in the peerJS library).
 * A message is an object with three attributes:
 * -> from: indicates who is the sender, 1 (the master) or 2 (the slave)
 * -> what: indicates the type of the message ( for example, setting to synchronize the devices on the game page)
 * -> content: the body of the message
 */
class Message {
    constructor(from, what, content) {
        this.from = from;
        this.what = what;
        this.content = content;
    }
}

/**
 * This function manages the game when it is started by the MASTER
 */
function gameManager() {
    var myName;
    var opponentName;

    if (player == 1) {
        // The MASTER send a message to the SLAVE when the game is started
        var changePage = new Message(1, "setting", "start");
        conn.send(changePage);

        myName = masterNickname;

        // The MASTER send its name to teh SLAVE
        conn.send(new Message(player, "name", myName));

        // The MASTER plays first
        isMyTurn = true;

        var divIsMyTurn = document.getElementById("divIsMyTurn");
        divIsMyTurn.innerText = "It's your turn!";
    } else {
        myName = slaveNickname;

        //The SLAVE send its name to the MASTER
        setTimeout(conn.send, 1000, new Message(player, "name", myName));
        var divIsMyTurn = document.getElementById("divIsMyTurn");
        divIsMyTurn.innerText = "It isn't your turn!";
    }

    // Manage the event generated by the receipt of a message
    conn.on('data', function(data) {
        // Analyze the type of the message
        switch(data.what) {
            // The setting message is recived by the SLAVE from the MASTER
            case "setting":
                if (data.content == "start") {
                    /**
                     * When the slave recive the setting message from the master
                     * it switches page to the game page.
                     */
                    toSlide("gamePage");
                }
                break;

            // The turn message contains the information about the moves made by the opponent    
            case "turn":
                isMyTurn = true; // When the opponent played, now is my turn
                var divIsMyTurn = document.getElementById("divIsMyTurn");
                divIsMyTurn.innerText = "It's your turn";
                
                // Update the local tic-tac-toe grid
                var num = data.from;
                grid[data.content[0]][data.content[1]] = num;
                var button = document.getElementById("btn" + data.content[0].toString() + data.content[1].toString());
                var img = document.createElement("img");
                img.src = "img/playerImg" + data.from + ".png";
                console.log("img/playerImg" + data.from + ".png");
                img.classList.add("imgSize");
                if (button.childNodes.length == 0) {
                    button.appendChild(img);
                }
                // After the move, check if someone has won
                checkWin();
                break;
            case "restart":
                restart();
                break;
        }
    })
}

/**
 * This function is called by the click on a cell of the grid
 * x and y are index of the cell in the tic-tac-toe grid
 */
function clicked(x, y) {
    var button = document.getElementById("btn" + x.toString() + y.toString());

    // You can click the cell only if is your turn and the cell is empty
    if(isMyTurn == true && grid[x][y] == 0){
        grid[x][y] = player; // Set the grid with the player number in this cell

        // Set the correct player image on the cell
        if (player == 1) {
            var img = document.createElement("img");
            img.src = "img/playerImg1.png";
            img.classList.add("imgSize");
            img.id = "icon";
            button.appendChild(img);
        } else {
            var img = document.createElement("img");
            img.src = "img/playerImg2.png";
            img.classList.add("imgSize");
            img.id = "icon";
            button.appendChild(img);
        }

        /**
         * Send a message to the other player, indicating this move
         */
        var pos = [x, y];
        conn.send(new Message(player, "turn", pos));

        // After playing, it's no longer my turn
        isMyTurn = false;
        var divIsMyTurn = document.getElementById("divIsMyTurn");
        divIsMyTurn.innerText = "It isn't your turn!";
    }

    // After the move, check if someone has won
    checkWin();
}

/**
 * This functions check if someone has won
 */
function  checkWin() {
    var winner = null;

    // Checking rows
    for(var i=0; i<3; i++) {
        if(grid[i][0] == grid[i][1] && grid[i][1] == grid[i][2] && grid[i][0] != 0) {
            winner = grid[i][0];
        }  
    }
    
    // Checking columns
    for(var j=0; j<3; j++) {
        if(grid[0][j] == grid[1][j] && grid[1][j] == grid[2][j] && grid[0][j] != 0) {
            winner = grid[0][j];
        }  
    }
    
    // Checking diagonals
    if(grid[0][0] == grid[1][1] && grid[1][1] == grid[2][2] && grid[0][0]!=0) {
        winner = grid[0][0];
    }
    if(grid[2][0] == grid[1][1] && grid[1][1] == grid[0][2] && grid[2][0]!=0) {
        winner = grid[2][0];
    }

    // If there is a winner, print it
    if (winner != null) {
        console.log("Player " + winner + " has won!");
        var gamePage = document.getElementById("gamePage");
        var winPopup = document.createElement("div");
        winPopup.classList.add("winPopUp");
        winPopup.id = "winPopUp";
        if (winner == player) {
            winPopup.innerHTML = "You won!<br><br><br>";
        } else {
            winPopup.innerHTML = "You lost!<br><br><br>";
        }
        var newGameButton = document.createElement("button");
        newGameButton.addEventListener('click', restart);
        newGameButton.innerText = "Play again";
        winPopup.appendChild(newGameButton)
        var toBlur = document.getElementById("gamePageElements");
        toBlur.classList.add("blured");
        gamePage.appendChild(winPopup);
        return;
    }

    //Checking if there is a draw
    var flag = true;
    for (var i = 0; i < 3; i++) {
        for (var j = 0; j < 3; j++) {
            if (grid[i][j] == 0) {
                flag = false;
                break;
            }
        }
    }
    
    if (flag) {
        console.log("Draw!");
        var gamePage = document.getElementById("gamePage");
        var winPopup = document.createElement("div");
        winPopup.classList.add("winPopUp");
        winPopup.id = "winPopUp";
        winPopup.innerHTML = "Draw!<br><br><br>";
        var newGameButton = document.createElement("button");
        newGameButton.innerText = "Play again";
        newGameButton.addEventListener('click', restart);
        winPopup.appendChild(newGameButton)
        var toBlur = document.getElementById("gamePageElements");
        toBlur.classList.add("blured");
        gamePage.appendChild(winPopup);
        return;
    }
    
    // If no winner and no draw, return
    return 0;
}

/**
 * This function generate a personalized PeerJS ID
 */
function generatingId() {
    return "galilei-" + Math.floor(Math.random() * 10).toString() + Math.floor(Math.random() * 10).toString() + Math.floor(Math.random() * 10).toString() + Math.floor(Math.random() * 10).toString();
}

/**
 * This function reset the game in order to play again
 */
function restart(){
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    for (var i = 0; i < 3; i++) {
        for (var j = 0; j < 3; j++) {
            var cell = document.getElementById("btn" + i.toString() + j.toString());
            while (cell.firstChild) { 
                cell.removeChild(cell.firstChild);  
            }
        }
    }

    var winPopup = document.getElementById("winPopUp");
    var gamePageElements = document.getElementById("gamePageElements");
    winPopup.remove();
    gamePageElements.classList.remove("blured");
    conn.send(new Message(player, "restart", null));
    round++;
    gameManager();
}